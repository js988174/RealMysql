# MySQL 서버 주요 구성 요소

## MySQL 엔진

MySQL 엔진은 클라이언트로 부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심으로 이루어져 있다.
MySQL 은 표준 SQL(ANSI SQL) 문법을 지원하기 때문에 표준 문법에 따라 작성된 다른 DBMS에서 사용하는 쿼리도 호환되어 실행 할 수 있다.


## 스토리지 엔진

실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로 부터 데이터를 읽어오는 부분을 스토리지 엔진이 담당 한다.

MySQL 에서는 여러가지 스토리지 엔진을 사용할 수 있다.
아래와 같이 테이블을 생성하게 되면 해당 테이블은 앞으로 정의 된 스토리지 엔진에서 처리하게 된다.

SQL> create table tb_test(col1 int, col2 varchar(100)) ENGINE=InnoDB;

위에서 생성한 테이블은 InnoDB 스토리지 엔진으로 정의 하였기 때문에 앞으로 쿼리의 처리는 InnoDB 스토리지 엔진에서 처리를 하게 된다.

각 스토리지 엔진은 성능 향상을 위해서 각각의 다른 형태의 캐시 기능을 내장하고 있다.


## 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽거나 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청 하게 되며,
이러한 요청을 핸들러(Handler) 요청이라고 하고, 여기서 사용 되는 API를 핸들러 API 라고 한다.

InnoDB 스토리지 엔진도 핸들러 API 를 이용해 MySQL 엔진과 데이터를 주고 받게 된다.
이러한 핸들러 사용에 대한 정보는 아래 명령어로 확인 할 수 있다.

SQL> show global status like '%Handler%';


## MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 동작한다.
그래서 크게 포그라운드 스레드와 백그라운드 스레드로 구분 할 수 있다.

MySQL 서버에서 실행 중인 스레드의 목록은 performance_schema 데이터베이스의 threads 테이블을 통해 확인 할 수 있다

SQL> select thread_id, name,type, processlist_user,processlist_host
from performance_schema.threads
order by type, thread_id;

확인되는 여러개의 스레드 중에서 'thread/sql/one_connection' 스레드가 실제 사용자의 요청을 처리 하는 포그라운드 스레드 이다.

백그라운드  스레드 개수는 MySQL 서버의 설정에 따라서 내용과 수는 가변적이며, 동일한 이름의 스레드가 2개 이상 보이는 것은 여러개 스레드가 동일 작업을 병렬로 처리하는 경우 이다. 


## 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 Mysql 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
작업을 마치고 커넥션을 종료하면 해당 스레드는 다시 스레드 캐시(Thread Cache) 로 돌아가게 된다.

MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만,
InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 작업은 백그라운드 스레드가 처리 하게 된다.

## 백그라운드 스레드

 * 인서트 버퍼(Insert Buffer)를 병합하는 스레드
 * 로그를 디스크로 기록하는 스레드
 * InnoDB 버퍼 풀의 데이터를 디스크로 기록하는 스레드
 * 데이터를 버퍼로 읽어 오는 스레드
 * 잠금이나 데드락을 모니터랑 하는 스레드
 
InnoDB 스토리지 엔진의 백그라운드 스레드에서 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 쓰기 작업을 처리하는 쓰기 스레드이다.
쓰기 스레드는 아주 많은 작업들을 백그라운드로 처리하기 때문에 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.
 
일반적인 상용 DMBS에서는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있고 InnoDB 또한 이러한 방식으로 쓰기 작업을 처리한다.(MyISAM은 쓰기 버퍼링 기능을 사용할 수 없음)

이외에 인서트 버퍼를 병합하는 스레드, 데이터를 버퍼로 읽어오는 스레드, 데드락이나 잠금을 모니터링하는 스레드 등 다양한 작업들이 백그라운드 스레드에서 처리된다.

## 플러그인 스토리지 엔진 모델

MySQL의 독특한 구조 중 대표적인 것이 플러그인 모델이다.

MySQL은 이미 많은 스토리지 엔진을 가지고 있지만 사용자의 요구사항과 필요에 의해 추가로 다른 형태의 스토리지 엔진이 필요 할 수도 있고,
이러한 요건을 바탕으로 직접 스토리지 엔진을 개발 하여 사용할 수 도 있다.

MySQL 에서는 핸들러(Handler) 라는 단어를 자주 접하게 될 것 이다.
프로그래밍에서 어떤 기능을 호출하기 위한 역할을 하는 객체를 핸들러(Handler) 라고 표현하며 MySQL 엔진이 스토리지 엔진을 조정하기 위해서 핸들러 라는 것을 사용하게 되는 것 이다.

각 스토리지 엔진에서 데이터를 읽거나 저장하기 위해서는 핸들러를 통해야 하며, 상태 변수 가운데 "Handler_" 로 시작하는 것이 많음을 확인 할 수도 있다.

## 쿼리 실행 구조

쿼리를 실행하는 관점에서 MySQL 구조를 간략하게 글로 설명과 기능별로 아래와 같이 나눠볼 수 있다.

쿼리 파서(Parser) -> 전처리기(Preprocessor) -> 쿼리 옵티마이저(Query Optimizer) -> 쿼리 실행기(Query Execution) -> 핸들러(스토리지 엔진)

### 쿼리 파서
들어온 쿼리를 MySQL이 인식할 수 있는 어휘나 기호로 분리해 트리 형태의 구조로 만들어내는 작업을 수행한다.
쿼리의 기본 문법 오류가 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 된다.

### 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
테이블 이름이나 컬럼 이름, 내장 함수와 같은 개체를 매핑해 객체의 존재 여부와 접근 권한 등을 확인하는 과정을 수행한다.

### 옵티마이저
쿼리 문장을 저렴한 비용(Cost)으로 가장 빠르게 처리 할지를 결정하는 역할 과 실행계획을 작성을 담당하며, DBMS의 두뇌에 해당한다고 할 수 있다.
 
### 실행 엔진
실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.
 
옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 가정했을때,
실행엔진이 핸들러에게 테이블을 만들어, WHERE 절에 일치하는 레코드 읽어와, 읽어온 레코드들 임시 테이블로 저장해등을 요청하고 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈에게 넘긴다.

### 핸들러(스토리지 엔진)
MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다.

### 스레드 폴
스레드 풀은 동시 처리 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중 할 수 있게 해서 서버 자원 소모를 줄이는데 목적이 있다.

# InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중에서 거의 유일하게 레코드 기반의 잠금을 제공하고 있으며, 때문에 높은 동시성 처리가 가능하고 또한 한정적이며 성능이 뛰어나다.

* 프라이머리 키에 의한 클러스터링
  * InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링 되어 저장됨. 즉, PK값 순서대로 디스크에 저장되고, 이로 인해 PK에 의한 레인지 스캔은 상당히 빨리 처리된다.
  
### 트랜잭션 지원 메타데이터
MySQL 서버 5.7 버전까지 테이블 구조를 파일 기반으로 관리했다.
하지만 이러한 파일 기반의 메타데이터는 생성 및 변경 작업에 트랜잭션을 지원하지 않아서 생성이나 변경 도중 MySQL 서버가 비정상 종료가 되면 일관성이 보장되지 않아 테이블이 깨지는 현상이 발생했다.

따라서 MySQL 8.0부터는 테이블 구조 정보나 스토어드 프로그램의 코드 관련 정보 등의 정보를 모두 InnoDB의 테이블에 저장되도록 변경된다.

Primary Key에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장 된다.

즉, Primary Key(프라이머리 키) 값의 순서대로 디스크에 저장된다는 뜻 이며, 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.

프라이머리 키가 클러스터링 인덱스 이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빠르게 처리가 되며 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정(쿼리의 실행계획에서 프라이머리 키가 선태될 확율이 높음) 이 된다.

오라클 DBMS 의 IOT 와 동일한 구조가 InnoDB에서는 일반적인 테이블의 구조가 되는 것 이다.


# InnoDb 스토리지 엔진 아키텍처
* InnoDb의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.
즉, 논리적인 주소로 사용한다.

* InnoDb에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.
       
